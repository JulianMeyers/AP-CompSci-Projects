
public class RecursionDemoRunner
{

	public static void main(String[] args)
	{
//		runMystery();
//		runMystery2();
//		runCollatz();
//		runPalindromes();
//		runContagion();
//		runTriangles();
		runFolders();
	}
	
	public static void runMystery()
	{
		System.out.println("MYSTERY RECURSION");
		System.out.println("This method does a nonsensical math thing - but it's a good example of the sort of problem that appears in the AP multiple choice.");
		
		int[] seedValues = {0,1,2,3,4,7};
		MysteryRecursionChecker mrc = new MysteryRecursionChecker();
		for (int seed:seedValues)
		{
			System.out.println(seed + "\t" + mrc.mystery(seed));
			
		}		
	}
	
	public static void runMystery2()
	{
		System.out.println("MYSTERY RECURSION2");
		System.out.println("Another kind of pointless example of recursion, but one that is similar to something found on the AP.");
		
		int[] seedValues = {1, 2, 3, 4, 8};
		MysteryRecursionChecker mrc = new MysteryRecursionChecker();
		for (int seed:seedValues)
		{
			System.out.println(seed + "\t" + mrc.mystery2(seed));
		}
	}
	
	
	public static void runCollatz()
	{
		// COLLATZ CONJECTURE
		System.out.println("COLLATZ CONJECTURE");
		System.out.println("This tests the Collatz Conjecture, namely that the sequence of numbers \ngenerated by the following rules always winds up at 1. \nThe sequence starts with a positive integer, N. \nAt each step, \n   •If the value of N is even, divide it by 2 to get the next N. \n   •Otherwise, multipy it by 3 and add 1 to get the next N. \nThis method produces the sequence of N values, starting at several different beginning points.");
		int[] seedValues = {1,2,3,4,5,6,13,33,100,121,500,501};
		CollatzChecker cc = new CollatzChecker();
		for (int i: seedValues)
		{
			System.out.println("=======================");
			cc.checkValue(i);
		}
	}
	
	public static void runPalindromes()
	{
		// PALINDROMES
		System.out.println("PALINDROMES");
		System.out.println("This method checks whether a given word is or is not a palindrome - that is, wether it looks the same forwards as backwards.\n We try this for several different words.");
		String[] potentialPalindromes = {"wow","cat","noon","bird","sows","a","ii","hi","racecar","amanaplanacanalpanama"};
		PalindromeChecker pc = new PalindromeChecker();
		for (String s : potentialPalindromes)
			System.out.println(pc.isPalindrome(s)+"\t"+s);
	}	
	
	
	public static void runContagion()
	{	
		// CONTAGION
		System.out.println("CONTAGION");
		System.out.println("In this demo, we are starting with a world consisting of a string with dividers, \"|\", and healthy peeps, \".\") in it. \nA contagion, \"*\", is introduced at some index and spreads through \nall the adjacent healthy peeps, but cannot penetrate the barriers.\nThis is tested for several different worlds and injection locations."); 
		String[] worlds = {"|........|||.....|", 
						   "|........|||.....|", 
						   "|........|||.....|", 
						   "|.......|...|.|.....|", 
						   "|.......|...|.|.....|", 
						   "|.......|...|.|.....|", 
						   "|........|", 
						   "||||||||||||",
						   "......."};
		
		int[] indices = {3, 15, 11, 10, 13, 17, 5, 8, 2};
		ContagionClass cc2 = new ContagionClass();
		for (int i=0; i<worlds.length; i++)
		{
			System.out.println("\n------------------------------");
			String[] theWorld = worlds[i].split(""); // turns this world into an array of 1-character strings.
			int numSteps = cc2.expandContagion(theWorld, indices[i]);
			if (numSteps ==0)
				cc2.printWorld(theWorld);
		}
	}
	public static void runTriangles()
	{
		//TRIANGLES
		System.out.println("TRIANGLES");
		System.out.println("For a given size, generates a right justified triangle and calculates the number of stars in it.\n We'll try this with several sizes.");
		int[] sizes = {3,5,2,1,0,13};
		TriangleChecker tc = new TriangleChecker();
		for (int i: sizes)
		{
			System.out.println("------------------------");
			int area = tc.generateTriangle(i);
			System.out.println("Size: "+i+"\tArea: "+area);
		}
		
	}
	
	public static void runFolders()
	{
		// FOLDERS
		System.out.println("FOLDERS");
		System.out.println("In this method, were are modelling a series of nested folders, some of which have files and/or subfolders.");
		
		// set up some sample folders in a nested configuration.
		Folder folderA = new Folder("A");
		folderA.addFile(9);
		folderA.addFile(10);
		folderA.addFile(11);
		
		Folder folderB = new Folder("B");
		folderB.addFile(2);
		folderB.addFile(3);
		folderB.addFile(4);
		
		Folder folderC = new Folder("C");
		folderC.addFile(5);
		folderC.addFile(6);
		folderC.addFile(7);
		
		Folder folderD = new Folder("D");
		folderD.addFile(8);
		
		Folder folderE = new Folder("E");
		
		Folder folderF = new Folder("F");
		
		Folder folderG = new Folder("G");
		folderG.addFile(12);
		folderG.addFile(13);
		folderG.addFile(14);
		folderG.addFile(15);

		Folder folderH = new Folder("H");
		folderH.addFile(1);
		
		Folder folderI = new Folder("I");
		
		Folder folderJ = new Folder("J");
		folderJ.addFile(16);
		folderJ.addFile(17);
		folderJ.addFile(18);
		folderJ.addFile(19);
		folderJ.addFile(20);
		folderJ.addFile(21);

		folderF.addFolder(folderA);
		folderF.addFolder(folderB);
		
		folderH.addFolder(folderC);
		
		folderI.addFolder(folderD);
		folderI.addFolder(folderE);
		
		folderG.addFolder(folderF);
		folderG.addFolder(folderI);
		
		folderJ.addFolder(folderG);
		folderJ.addFolder(folderH);
		
		// now let's demo these folders, showing their file structures and their sizes.
		Folder[] foldersToDemo = {folderB, folderF, folderA, folderG, folderE, folderJ};
	
		for (Folder f: foldersToDemo)
		{
			System.out.println("------------------------------------------");
			System.out.println("Displaying folder "+f.getName());
			f.printFolder();
			System.out.println("Size of folder "+f.getName()+": "+ f.getSize()+" MB");
		}
		
	}

}
